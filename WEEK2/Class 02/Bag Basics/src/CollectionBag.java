import java.util.Collection;
import java.util.Iterator;

/**
 * 
 * @author mhrybyk
 *
 *         Here is a version of Bag called that implements the standard java
 *         Collection interface.
 * 
 *         Have made this a bit simpler. No checking for capacity or integrity.
 * 
 *         Stubs are generated by eclipse.
 *
 */
public class CollectionBag<T> implements Collection<T> {

	private T[] bag;
	private int numberOfEntries;
	private static final int DEFAULT_CAPACITY = 25; // Initial capacity of bag

	/** Creates an empty bag whose initial capacity is 25. */
	public CollectionBag() {
		this(DEFAULT_CAPACITY);
	} // end default constructor

	/**
	 * Creates an empty bag having a given initial capacity.
	 * 
	 * @param initialCapacity The integer capacity desired.
	 */
	@SuppressWarnings("unchecked")
	public CollectionBag(int initialCapacity) {

		bag = (T[]) new Object[initialCapacity];
		numberOfEntries = 0;
	} // end constructor

	/**
	 * Like Bag, just get the number of entries in the bag.
	 */
	@Override
	public int size() {
		return numberOfEntries;
	}

	@Override
	public boolean isEmpty() {

		return numberOfEntries == 0;
	}

	@Override
	public boolean add(T e) {
		if (numberOfEntries < bag.length) {
			bag[numberOfEntries] = e;
			numberOfEntries++;
			return true;
		} else
			return false;
	}

	/**
	 * Finds an the first object in a bag and returns its index.
	 * 
	 * @param entry object to test.
	 * @return index value in the bag, or a -1 if entry is null or does not exist
	 */
	public int find(T entry) {
		if (entry == null)
			return -1;
		for (int i = 0; i < numberOfEntries; i++) {
			if (bag[i].equals(entry)) {
				return i;
			}
		}
		return -1;

	}
	
	/**
	 * Finds an object in a bag, and returns true if exists
	 */
	
	public boolean contains(Object o) {
		@SuppressWarnings("unchecked")
		int index = find((T) o);
		if (index < 0)
			return false;
		return true;
	}

	/**
	 * Remove an object from a bag, and return true if successful
	 */
	public boolean remove(Object o) {
		@SuppressWarnings("unchecked")
		int index = find((T) o);

		if (index < 0)
			return false;
		else
			return remove(index);
	}

	/**
	 * Remove an entry in a bag at a location.
	 * Swap the last entry with the one being removed, and then
	 * set the last entry in the bag to null.
	 * @param index Index of entry to be removed
	 * @return true if successful
	 */
	public boolean remove(int index) {
		if(index < 0 || isEmpty())
			return false;
		
		if (index < numberOfEntries) {
			int lastIndex = numberOfEntries - 1;
			bag[index] = bag[lastIndex];
			bag[lastIndex] = null;
			numberOfEntries--;
			return true;
		} else
			return false;
	}

	/**
	 * Remove the last entry from the bag.
	 * @return the entry or null if the bag is empty
	 */
	public T remove() {
		if (isEmpty())
			return (null);
		else {
			T entry = bag[numberOfEntries - 1];
			bag[numberOfEntries - 1] = null;
			numberOfEntries--;
			return entry;
		}

	}

	@Override
	public void clear() {
		for (int i = 0; i < numberOfEntries; i++)
			bag[i] = null;
		numberOfEntries = 0;
	}

	@Override
	public boolean containsAll(Collection<?> c) {
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean addAll(Collection<? extends T> c) {
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean removeAll(Collection<?> c) {
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean retainAll(Collection<?> c) {
		throw new UnsupportedOperationException();
	}

	@Override
	public Iterator<T> iterator() {
		// TODO Auto-generated method stub
		// we won't use this in our examples
		throw new UnsupportedOperationException();
	}

	@Override
	public T[] toArray() {
		throw new UnsupportedOperationException();
	}

	@Override
	public <T> T[] toArray(T[] a) {
		// TODO Auto-generated method stub
		throw new UnsupportedOperationException();
	}

}
